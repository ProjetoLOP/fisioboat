// LISCENSE 1.0 - DeepSquat

// Vari√°veis globais para armazenar estados e configura√ß√µes
let detectorReady = false;
let detector;
const threshold = 0.3;       // Valor m√≠nimo de score

// Referencial inicial (posi√ß√£o em p√©)
let normalizedStartDist = { left: null, right: null };

// Sinal suavizado (EMA) de depth e hist√≥rico para regress√£o
let emaDepth = 0;
const EMA_ALPHA = 0.4;        // Quanto menor, mais suave
const emaHistory = [];
const HISTORY_SIZE = 4;

// Limiares de detec√ß√£o de tend√™ncia
const TREND_SLOPE_THRESHOLD = 0.005;
const RESTING_THRESHOLD = 0.04;

// Controle de estado e temporiza√ß√£o
let lastPerformingTime = null;
const MIN_DURATION_MS = 300; // M√≠nimo de 300ms entre "performing" e "completed"
let movementState = "idle"; // "idle" | "performing" | "completed"

// Profundidade m√°xima registrada no ciclo atual
let maxDepthRecorded = 0;

// Fun√ß√£o para calcular dist√¢ncia euclidiana
function calculateDistance(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}

// Normaliza pela largura do quadril
function normalize(dist, hipL, hipR) {
  const ref = calculateDistance(hipL, hipR);
  return dist / ref;
}

// Profundidade din√¢mica no frame atual
function computeDepth(normLeft, normRight) {
  const dL = 1 - (normLeft / normalizedStartDist.left);
  const dR = 1 - (normRight / normalizedStartDist.right);
  return Math.min(dL, dR);
}

// Regress√£o linear simples para obter a inclina√ß√£o (slope)
function linearSlope(values) {
  const n = values.length;
  const xMean = (n - 1) / 2;
  const yMean = values.reduce((sum, v) => sum + v, 0) / n;
  let num = 0, den = 0;
  for (let i = 0; i < n; i++) {
    const dx = i - xMean;
    num += dx * (values[i] - yMean);
    den += dx * dx;
  }
  return num / den;
}

// Avalia a tend√™ncia do movimento a partir do hist√≥rico suavizado
function evaluateTrend() {
  // Primeiro: se atingiu o estado de descanso (em p√©)
  if (emaDepth <= RESTING_THRESHOLD) {
    // Se antes estava descendo (performing), agora completa
    if (movementState === "performing") {
      const elapsed = Date.now() - lastPerformingTime;
      if (elapsed >= MIN_DURATION_MS) {
        movementState = "completed";
        console.log("Estado: completed");

        const detail = {
          depth: maxDepthRecorded,
          duration: elapsed,
          instant: new Date().toISOString()
        };

        window.dispatchEvent(new CustomEvent("squatDetected", { detail }));
        window.dispatchEvent(new CustomEvent("completed", { detail }));
      }
    }

    // Em todo caso, volta ao idle
    if (movementState !== "idle") {
      movementState = "idle";
      console.log("Estado: idle");
    }
    // Reinicia para o pr√≥ximo ciclo
    emaHistory.length = 0;
    maxDepthRecorded = 0;
    return;
  }

  // S√≥ analisa descida/subida se n√£o est√° em repouso e tem hist√≥rico
  if (emaHistory.length < HISTORY_SIZE) return;

  const slope = linearSlope(emaHistory);

  // Descendo (profundidade aumentando)
  if (slope > TREND_SLOPE_THRESHOLD) {
    if (movementState !== "performing") {
      movementState = "performing";
      lastPerformingTime = Date.now();
      console.log("Estado: performing");
      window.dispatchEvent(new CustomEvent("performing"));
    }
  }

  // **N√£o** verificamos mais subida aqui ‚Äì
  // o complete s√≥ acontece ao voltar ao estado de descanso acima.
}

// Extrai apenas keypoints confi√°veis (score > threshold)
function extractKeypoints(keypoints) {
  const filtered = keypoints.filter(kp => kp.score > threshold);
  return {
    leftHip: filtered.find(kp => kp.name === "left_hip"),
    rightHip: filtered.find(kp => kp.name === "right_hip"),
    leftKnee: filtered.find(kp => kp.name === "left_knee"),
    rightKnee: filtered.find(kp => kp.name === "right_knee"),
  };
}

// Reset do hist√≥rico quando um squat √© detectado
window.addEventListener("squatDetected", () => {
  emaHistory.length = 0;
  maxDepthRecorded = 0;
});

// Prepara o detector MoveNet
async function prepareDetector() {
  console.log("[prepareDetector] Carregando modelo MoveNet...");

  const t0 = performance.now();

  try {
    detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );
  } catch (err) {
    console.error("[prepareDetector] Erro ao criar detector:", err);
    return;
  }

  console.log(`[prepareDetector] Modelo carregado (${Math.round(performance.now() - t0)}ms).`);
  console.log("[prepareDetector] Iniciando warmup sint√©tico (sem v√≠deo)...");

  // üî• Criar uma imagem fake (tensor preto) para "aquecer" o modelo
  const warmupStart = performance.now();

  try {
    const fakeImage = tf.zeros([192, 192, 3]); // MoveNet Lightning espera 192x192 RGB
    await detector.estimatePoses(fakeImage);
    fakeImage.dispose();
  } catch (err) {
    console.warn("[prepareDetector] Erro no warmup sint√©tico:", err);
  }

  const warmupElapsed = Math.round(performance.now() - warmupStart);
  console.log(`[prepareDetector] Warmup conclu√≠do (${warmupElapsed}ms).`);

  detectorReady = true;
  window.dispatchEvent(new CustomEvent("detector:ready"));
  console.log("[prepareDetector] Detector pronto e aquecido (sem v√≠deo).");
}

const POSE_INTERVAL_MS = 80; // ~12.5 fps
let lastPoseTime = 0;

// Loop principal de detec√ß√£o de pose
async function detectPose(time) {
  if (!detector) return;

  if (time - lastPoseTime >= POSE_INTERVAL_MS) {
    console.log("process!")
    lastPoseTime = time;

    const video = document.getElementById("video");
    const poses = await detector.estimatePoses(video);

    // todo teu processamento continua igual
    processPose(poses);
  }

  requestAnimationFrame(detectPose);
}

function processPose(poses) {
  if (poses.length > 0) {
    const kp = extractKeypoints(poses[0].keypoints);
    if (kp.leftHip && kp.rightHip && kp.leftKnee && kp.rightKnee) {
      const rawL = calculateDistance(kp.leftHip, kp.leftKnee);
      const rawR = calculateDistance(kp.rightHip, kp.rightKnee);
      const normL = normalize(rawL, kp.leftHip, kp.rightHip);
      const normR = normalize(rawR, kp.leftHip, kp.rightHip);

      // Define a posi√ß√£o em p√© inicial
      if (normalizedStartDist.left === null) {
        normalizedStartDist.left = normalize(rawL, kp.leftHip, kp.rightHip);
        normalizedStartDist.right = normalize(rawR, kp.leftHip, kp.rightHip);
        window.dispatchEvent(new CustomEvent("pose:ready"));
        console.log("Postura inicial definida.");
      } else {
        // Calcula a profundidade bruta e atualiza depth m√°ximo
        const depth = computeDepth(normL, normR);
        if (depth > maxDepthRecorded) maxDepthRecorded = depth;

        // Filtra com EMA
        emaDepth = EMA_ALPHA * depth + (1 - EMA_ALPHA) * emaDepth;

        // Atualiza hist√≥rico
        emaHistory.push(emaDepth);
        if (emaHistory.length > HISTORY_SIZE) {
          emaHistory.shift();
        }

        // Analisa a tend√™ncia do movimento
        evaluateTrend();
      }
    }
  }
}