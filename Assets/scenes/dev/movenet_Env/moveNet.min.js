// Variáveis globais para armazenar estados e configurações
let detectorReady = false;
let detector;
let threshold = 0.3; // Valor mínimo de score

let squatStartDistance = { left: null, right: null };
let squatEndDistance   = { left: Infinity, right: Infinity };
let isSquatting        = false;
let squatFrames        = 0;
let stabilityFrames    = 3; // Número de frames para considerar estabilidade
let isFirstSquat       = false; // Flag para o primeiro agachamento

// === ADICIONADO PARA PROFUNDIDADE ===
let normalizedStartDist = { left: null, right: null };
let normalizedMinDist   = { left: Infinity, right: Infinity };

// === ADICIONADO PARA VERIFICAÇÃO DE TEMPO ENTRE EVENTOS ===
let lastPerformingTime = null;
const MIN_DURATION_MS  = 300; // Mínimo de 300ms entre performing e completed

// === NOVO: estado atual do movimento ===
let movementState = "idle"; // "idle" | "performing" | "completed"

// Função para calcular a distância euclidiana
function calculateDistance(pointA, pointB) {
  return Math.hypot(pointA.x - pointB.x, pointA.y - pointB.y);
}

// Função para normalizar uma distância pelo width do quadril
function normalize(dist, hipLeft, hipRight) {
  const ref = calculateDistance(hipLeft, hipRight);
  return dist / ref;
}

// === FUNÇÃO DE PROFUNDIDADE DINÂMICA ===
// Recebe a distância normalizada atual e compara com a inicial
function computeDepth(normLeft, normRight) {
  const depthL = 1 - (normLeft / normalizedStartDist.left);
  const depthR = 1 - (normRight / normalizedStartDist.right);
  return Math.min(depthL, depthR);
}

// Listener para resetar dados após detecção válida
window.addEventListener("squatDetected", () => {
  normalizedMinDist = { left: Infinity, right: Infinity };
});

// Monta o detector MoveNet
async function prepareDetector() {
  detector = await poseDetection.createDetector(
    poseDetection.SupportedModels.MoveNet,
    { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
  );
  detectorReady = true;

  window.dispatchEvent(new CustomEvent("detector:ready"));
  console.log("Detector pronto.");
}

// Loop principal de detecção
async function detectPose() {
  if (!detector) return;

  const video = document.getElementById("video");
  const poses = await detector.estimatePoses(video);

  if (poses.length > 0) {
    const kp = extractKeypoints(poses[0].keypoints);
    if (kp.leftHip && kp.rightHip && kp.leftKnee && kp.rightKnee) {
      const rawLeftD  = calculateDistance(kp.leftHip, kp.leftKnee);
      const rawRightD = calculateDistance(kp.rightHip, kp.rightKnee);
      const normLeft  = normalize(rawLeftD, kp.leftHip, kp.rightHip);
      const normRight = normalize(rawRightD, kp.leftHip, kp.rightHip);

      // Atualiza o mínimo para o evento final
      if (normalizedStartDist.left !== null && isSquatting) {
        normalizedMinDist.left  = Math.min(normalizedMinDist.left,  normLeft);
        normalizedMinDist.right = Math.min(normalizedMinDist.right, normRight);
      }

      // Calcula e exibe a profundidade em tempo real
      const currentDepth = computeDepth(normLeft, normRight);
      console.log("Profundidade atual:", currentDepth.toFixed(3));

      processPose(kp, normLeft, normRight);
    }
  }

  requestAnimationFrame(detectPose);
}

// Extrai apenas keypoints com score acima do threshold
function extractKeypoints(keypoints) {
  const filtered = keypoints.filter(kp => kp.score > threshold);
  return {
    leftHip:    filtered.find(kp => kp.name === "left_hip"),
    rightHip:   filtered.find(kp => kp.name === "right_hip"),
    leftKnee:   filtered.find(kp => kp.name === "left_knee"),
    rightKnee:  filtered.find(kp => kp.name === "right_knee"),
  };
}

// Exibe a profundidade a cada 10ms (ou use apenas o console acima)
const depthDisplay = document.querySelector(".depth");
setInterval(() => {
  // se quiser usar em DOM: 
  // depthDisplay.textContent = currentDepth.toFixed(3);
  // aqui mantemos o log por performance
}, 10);

// Processa o estado do agachamento
function processPose(pose, normLeft, normRight) {
  const { leftHip, rightHip, leftKnee, rightKnee } = pose;
  const leftDist  = calculateDistance(leftHip, leftKnee);
  const rightDist = calculateDistance(rightHip, rightKnee);

  // Definição das distâncias iniciais (posição em pé)
  if (squatStartDistance.left === null) {
    squatStartDistance = { left: leftDist, right: rightDist };
    normalizedStartDist.left  = normalize(leftDist, leftHip, rightHip);
    normalizedStartDist.right = normalize(rightDist, leftHip, rightHip);

    window.dispatchEvent(new CustomEvent("pose:ready"));
    console.log("Distâncias iniciais definidas.");
    return;
  }

  // Fase de descida
  if ((leftDist < squatStartDistance.left || rightDist < squatStartDistance.right) && !isSquatting) {
    squatFrames++;
    squatEndDistance.left  = Math.min(leftDist,  squatEndDistance.left);
    squatEndDistance.right = Math.min(rightDist, squatEndDistance.right);

    if (squatFrames >= stabilityFrames) {
      isSquatting   = true;
      squatFrames   = 0;
      lastPerformingTime = Date.now();
      movementState = "performing";
      window.dispatchEvent(new CustomEvent("performing"));
      return;
    }
  }
  // Fase de subida
  else if ((leftDist > squatStartDistance.left || rightDist > squatStartDistance.right) && isSquatting) {
    squatFrames++;
    if (squatFrames >= stabilityFrames) {
      squatFrames = 0;
      const now      = Date.now();
      const elapsed  = now - (lastPerformingTime || 0);

      // Se muito rápido, ignora
      if (elapsed < MIN_DURATION_MS) {
        isSquatting   = false;
        movementState = "idle";
        return;
      }

      // Finaliza o agachamento
      isSquatting   = false;
      movementState = "completed";

      // Cálculo de profundidade final usando o mínimo registrado
      const finalDepth = computeDepth(normalizedMinDist.left, normalizedMinDist.right);
      if (finalDepth < 0.05) {
        movementState = "idle";
        return;
      }

      const detail = {
        depth:    finalDepth,
        duration: elapsed,
        instant:  new Date().toISOString()
      };

      window.dispatchEvent(new CustomEvent("squatDetected", { detail: { depth: finalDepth, instant: detail.instant } }));
      if (!isFirstSquat) {
        window.dispatchEvent(new CustomEvent("firstSquat"));
        isFirstSquat = true;
      }
      window.dispatchEvent(new CustomEvent("completed", { detail }));

      return;
    }
  }
  else {
    squatFrames = 0;
  }
}