// Variáveis globais para armazenar estados e configurações
let detectorReady = false;
let detector;
let threshold = 0.3; // Valor mínimo de score
let squatStartDistance = { left: null, right: null };
let squatEndDistance = { left: Infinity, right: Infinity };
let isSquatting = false;
let squatFrames = 0;
let stabilityFrames = 3; // Número de frames para considerar estabilidade
let isFirstSquat = false; // Flag para o primeiro agachamento

// === ADICIONADO PARA PROFUNDIDADE ===
let normalizedStartDist = { left: null, right: null };
let normalizedMinDist = { left: Infinity, right: Infinity };

// === ADICIONADO PARA VERIFICAÇÃO DE TEMPO ENTRE EVENTOS ===
let lastPerformingTime = null;
const MIN_DURATION_MS = 300; // Mínimo de 300ms entre performing e completed

// === NOVO: estado atual do movimento ===
let movementState = "idle"; // "idle" | "performing" | "completed"

// Função para calcular a distância euclidiana
function calculateDistance(pointA, pointB) {
  return Math.hypot(pointA.x - pointB.x, pointA.y - pointB.y);
}

// Função para normalizar uma distância pelo width do quadril
function normalize(dist, hipLeft, hipRight) {
  const ref = calculateDistance(hipLeft, hipRight);
  return dist / ref;
}

// Função que calcula profundidade
function computeDepth() {
  const depthL = 1 - (normalizedMinDist.left / normalizedStartDist.left);
  const depthR = 1 - (normalizedMinDist.right / normalizedStartDist.right);
  return Math.min(depthL, depthR);
}

// Função para calcular profundidade e disparar evenfto (se for válida)
function computeDepthAndDispatch() {
  const depth = computeDepth();

  // Verifica se a profundidade é válida (não negativa)
  if (depth < 0.05) return;

  let level;
  if (depth < 0.10) level = "raso";
  else if (depth < 0.25) level = "paralelo";
  else level = "profundo";

  const detail = { depth, level, instant: new Date().toISOString() };
  console.log(detail);

  const squatEvent = new CustomEvent("squatDetected", { detail });
  window.dispatchEvent(squatEvent);

  if (!isFirstSquat) {
    const firstSquatEvent = new CustomEvent("firstSquat");
    window.dispatchEvent(firstSquatEvent);
    isFirstSquat = true;
  }
}

// Listener para resetar dados após detecção válida
window.addEventListener("squatDetected", () => {
  normalizedMinDist = { left: Infinity, right: Infinity };
});

async function prepareDetector() {
  detector = await poseDetection.createDetector(
    poseDetection.SupportedModels.MoveNet,
    { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
  );
  detectorReady = true;

  const readyDetector = new CustomEvent("detector:ready");
  window.dispatchEvent(readyDetector);

  console.log("Detector pronto.");
}

async function detectPose() {
  if (!detector) return;

  const video = document.getElementById("video");
  const poses = await detector.estimatePoses(video);

  if (poses.length > 0) {
    const extractedKeypoints = extractKeypoints(poses[0].keypoints);

    if (
      extractedKeypoints.leftHip &&
      extractedKeypoints.rightHip &&
      extractedKeypoints.leftKnee &&
      extractedKeypoints.rightKnee
    ) {
      const rawLeftD = calculateDistance(extractedKeypoints.leftHip, extractedKeypoints.leftKnee);
      const rawRightD = calculateDistance(extractedKeypoints.rightHip, extractedKeypoints.rightKnee);
      const normLeft = normalize(rawLeftD, extractedKeypoints.leftHip, extractedKeypoints.rightHip);
      const normRight = normalize(rawRightD, extractedKeypoints.leftHip, extractedKeypoints.rightHip);

      if (normalizedStartDist.left !== null && isSquatting) {
        normalizedMinDist.left = Math.min(normalizedMinDist.left, normLeft);
        normalizedMinDist.right = Math.min(normalizedMinDist.right, normRight);
      }

      const movementStatus = processPose(extractedKeypoints);
      if (movementStatus) console.log(movementStatus);
    }
  }

  requestAnimationFrame(detectPose);
}

function extractKeypoints(keypoints) {
  const filtered = keypoints.filter((kp) => kp.score > threshold);
  return {
    leftHip: filtered.find((kp) => kp.name === "left_hip"),
    rightHip: filtered.find((kp) => kp.name === "right_hip"),
    leftKnee: filtered.find((kp) => kp.name === "left_knee"),
    rightKnee: filtered.find((kp) => kp.name === "right_knee"),
  };
}

function processPose(pose) {
  const { leftHip, rightHip, leftKnee, rightKnee } = pose;

  const leftDistance = calculateDistance(leftHip, leftKnee);
  const rightDistance = calculateDistance(rightHip, rightKnee);

  // Definição das distâncias iniciais
  if (squatStartDistance.left === null || squatStartDistance.right === null) {
    squatStartDistance = { left: leftDistance, right: rightDistance };
    normalizedStartDist.left = normalize(leftDistance, leftHip, rightHip);
    normalizedStartDist.right = normalize(rightDistance, leftHip, rightHip);

    const readyPose = new CustomEvent("pose:ready");
    window.dispatchEvent(readyPose);

    console.log("Distâncias iniciais definidas.");
    return;
  }

  // Fase de descida
  if (
    (leftDistance < squatStartDistance.left || rightDistance < squatStartDistance.right) &&
    !isSquatting
  ) {
    squatFrames++;
    squatEndDistance.left = Math.min(leftDistance, squatEndDistance.left);
    squatEndDistance.right = Math.min(rightDistance, squatEndDistance.right);

    if (squatFrames >= stabilityFrames) {
      isSquatting = true;
      squatFrames = 0;

      // Transição para performing?
      if (movementState !== "performing") {
        lastPerformingTime = Date.now();
        movementState = "performing";
      }

      const performingEvent = new CustomEvent("performing");
      window.dispatchEvent(performingEvent);

      return "performing";
    }
  }
  // Fase de subida
  else if (
    (leftDistance > squatStartDistance.left || rightDistance > squatStartDistance.right) &&
    isSquatting
  ) {
    squatFrames++;

    if (squatFrames >= stabilityFrames) {
      squatFrames = 0;

      const now = Date.now();
      const timeDiff = now - (lastPerformingTime || 0);

      // Se muito rápido, ignora e reseta estado
      if (timeDiff < MIN_DURATION_MS) {
      const depth = computeDepth();
        console.log("Agachamento ignorado por tempo muito curto:", timeDiff, "ms", "Depth:", depth);
        isSquatting = false;
        movementState = "idle";
        return;
      }

      isSquatting = false;
      movementState = "completed";

      // Só despacha evento se a profundidade for válida
      const depth = computeDepth();
      if (depth < 0.05) {
        movementState = "idle";
        return;
      }

      // Prepara detalhes incluindo duração
      const detail = {
        depth,
        duration: timeDiff,
        instant: new Date().toISOString()
      };
      console.log(detail);

      // Evento squatDetected mantém apenas depth, mas event 'completed' terá duration
      const squatEvent = new CustomEvent("squatDetected", { detail: { depth, level: detail.level, instant: detail.instant } });
      window.dispatchEvent(squatEvent);

      if (!isFirstSquat) {
        const firstSquatEvent = new CustomEvent("firstSquat");
        window.dispatchEvent(firstSquatEvent);
        isFirstSquat = true;
      }

      // Agora incluo duration no evento 'completed'
      const completeEvent = new CustomEvent("completed", { detail });
      window.dispatchEvent(completeEvent);

      // Retorna um objeto com status e duração
      return { status: "completed", duration: timeDiff };
    }
  }
  else {
    squatFrames = 0;
  }
}
