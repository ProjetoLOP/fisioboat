// LISCENSE 1.0 - DeepSquat

// Variáveis globais para armazenar estados e configurações
let isDetecting = false;
let detectorReady = false;
let detector;
const threshold = 0.3;       // Valor mínimo de score

// Referencial inicial (posição em pé)
let normalizedStartDist = { left: null, right: null };

// Sinal suavizado (EMA) de depth e histórico para regressão
let emaDepth = 0;
const EMA_ALPHA = 0.2;        // Quanto menor, mais suave
const emaHistory = [];
const HISTORY_SIZE = 4;

// Limiares de detecção de tendência
const TREND_SLOPE_THRESHOLD = 0.005;
const RESTING_THRESHOLD = 0.02;

// Controle de estado e temporização
let lastPerformingTime = null;
const MIN_DURATION_MS = 300; // Mínimo de 300ms entre "performing" e "completed"
let movementState = "idle"; // "idle" | "performing" | "completed"

// Profundidade máxima registrada no ciclo atual
let maxDepthRecorded = 0;

// Função para calcular distância euclidiana
function calculateDistance(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}

// Normaliza pela largura do quadril
function normalize(dist, hipL, hipR) {
  const ref = calculateDistance(hipL, hipR);
  return dist / ref;
}

// Profundidade dinâmica no frame atual
function computeDepth(normLeft, normRight) {
  const dL = 1 - (normLeft / normalizedStartDist.left);
  const dR = 1 - (normRight / normalizedStartDist.right);
  return Math.min(dL, dR);
}

// Regressão linear simples para obter a inclinação (slope)
function linearSlope(values) {
  const n = values.length;
  const xMean = (n - 1) / 2;
  const yMean = values.reduce((sum, v) => sum + v, 0) / n;
  let num = 0, den = 0;
  for (let i = 0; i < n; i++) {
    const dx = i - xMean;
    num += dx * (values[i] - yMean);
    den += dx * dx;
  }
  return num / den;
}

// Avalia a tendência do movimento a partir do histórico suavizado
function evaluateTrend() {
  // Primeiro: se atingiu o estado de descanso (em pé)
  if (emaDepth <= RESTING_THRESHOLD) {
    // Se antes estava descendo (performing), agora completa
    if (movementState === "performing") {
      const elapsed = Date.now() - lastPerformingTime;
      if (elapsed >= MIN_DURATION_MS) {
        movementState = "completed";
        // console.log("Estado: completed");

        const detail = {
          depth: maxDepthRecorded,
          duration: elapsed,
          instant: new Date().toISOString()
        };

        window.dispatchEvent(new CustomEvent("completed", { detail }));
      }
    }

    // Em todo caso, volta ao idle
    if (movementState !== "idle") {
      movementState = "idle";
      // console.log("Estado: idle");
    }
    // Reinicia para o próximo ciclo
    emaHistory.length = 0;
    maxDepthRecorded = 0;
    return;
  }

  // Só analisa descida/subida se não está em repouso e tem histórico
  if (emaHistory.length < HISTORY_SIZE) return;

  const slope = linearSlope(emaHistory);

  // Descendo (profundidade aumentando)
  if (slope > TREND_SLOPE_THRESHOLD) {
    if (movementState !== "performing") {
      movementState = "performing";
      lastPerformingTime = Date.now();
      // console.log("Estado: performing");
      window.dispatchEvent(new CustomEvent("performing"));
    }
  }

  // **Não** verificamos mais subida aqui –
  // o complete só acontece ao voltar ao estado de descanso acima.
}

// Extrai apenas keypoints confiáveis (score > threshold)
function extractKeypoints(keypoints) {
  const filtered = keypoints.filter(kp => kp.score > threshold);
  return {
    leftHip: filtered.find(kp => kp.name === "left_hip"),
    rightHip: filtered.find(kp => kp.name === "right_hip"),
    leftKnee: filtered.find(kp => kp.name === "left_knee"),
    rightKnee: filtered.find(kp => kp.name === "right_knee"),
  };
}

// Reset do histórico quando um squat é completado
window.addEventListener("completed", () => {
  emaHistory.length = 0;
  maxDepthRecorded = 0;
});

// Prepara o detector MoveNet
async function prepareDetector() {
  detector = await poseDetection.createDetector(
    poseDetection.SupportedModels.MoveNet,
    { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
  );
  detectorReady = true;
  window.dispatchEvent(new CustomEvent("detector:ready"));
  console.log("Detector pronto.");
}

// Loop principal de detecção de pose
async function detectPose() {
  if (!isDetecting || !detector) return;

  const video = document.getElementById("video");
  const poses = await detector.estimatePoses(video);

  if (poses.length > 0) {
    const kp = extractKeypoints(poses[0].keypoints);
    if (kp.leftHip && kp.rightHip && kp.leftKnee && kp.rightKnee) {
      const rawL = calculateDistance(kp.leftHip, kp.leftKnee);
      const rawR = calculateDistance(kp.rightHip, kp.rightKnee);
      const normL = normalize(rawL, kp.leftHip, kp.rightHip);
      const normR = normalize(rawR, kp.leftHip, kp.rightHip);

      // Define a posição em pé inicial
      if (normalizedStartDist.left === null) {
        normalizedStartDist.left = normalize(rawL, kp.leftHip, kp.rightHip);
        normalizedStartDist.right = normalize(rawR, kp.leftHip, kp.rightHip);
        window.dispatchEvent(new CustomEvent("pose:ready"));
        console.log("Postura inicial definida.");
      } else {
        // Calcula a profundidade bruta e atualiza depth máximo
        const depth = computeDepth(normL, normR);
        if (depth > maxDepthRecorded) maxDepthRecorded = depth;

        // Filtra com EMA
        emaDepth = EMA_ALPHA * depth + (1 - EMA_ALPHA) * emaDepth;

        // Atualiza histórico
        emaHistory.push(emaDepth);
        if (emaHistory.length > HISTORY_SIZE) {
          emaHistory.shift();
        }

        // Analisa a tendência do movimento
        evaluateTrend();
      }
    }
  }

  requestAnimationFrame(detectPose);
}

function stopDetection() {
  isDetecting = false;
}

function startDetection() {
  if (!isDetecting) {
    isDetecting = true;
    detectPose();
  }
}