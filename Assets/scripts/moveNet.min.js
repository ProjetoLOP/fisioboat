// Variáveis globais para armazenar estados e configurações
let detectorReady = false;
let detector;
let threshold = 0.3; // Valor mínimo de score
let squatStartDistance = { left: null, right: null };
let squatEndDistance = { left: Infinity, right: Infinity };
let isSquatting = false;
let isUpSquatting = false;
let squatFrames = 0;
let upSquatFrames = 0;
let stabilityFrames = 3; // Número de frames para considerar estabilidade
let isFirstSquat = false; // Flag para o primeiro agachamento
let currentSquatPoses = [];
let quality;
let squatDepth = { left: Infinity, right: infinity };
let minimoSquat = 0.5;
let first = true;
let erro = 0.02;

// Função para preparar o detector
async function prepareDetector() {
    detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );
    detectorReady = true;

    const readyDetector = new CustomEvent("detector:ready");
    window.dispatchEvent(readyDetector);

    console.log("Detector pronto.");
}

// Função para detectar poses continuamente
async function detectPose() {
    if (!detector) return null;

    const video = document.getElementById("video");
    const poses = await detector.estimatePoses(video);

    if (poses.length > 0) {
        const extractedKeypoints = extractKeypoints(poses[0].keypoints);
        if (extractedKeypoints.leftHip && extractedKeypoints.rightHip &&
            extractedKeypoints.leftKnee && extractedKeypoints.rightKnee) {
            const movementStatus = processPose(extractedKeypoints);
            if (movementStatus) console.log(movementStatus);
        }
    }

    requestAnimationFrame(detectPose);
}

// Função que extrai os keypoints filtrando pelo score
function extractKeypoints(keypoints) {
    const filtered = keypoints.filter((kp) => kp.score > threshold);
    return {
        leftHip: filtered.find((kp) => kp.name === "left_hip"),
        rightHip: filtered.find((kp) => kp.name === "right_hip"),
        leftKnee: filtered.find((kp) => kp.name === "left_knee"),
        rightKnee: filtered.find((kp) => kp.name === "right_knee"),
    };
}

// Função que processa a pose e calcula as distâncias dos keypoints
function processPose(pose) {
    const { leftHip, rightHip, leftKnee, rightKnee } = pose;

    const leftDistance = calculateDistance(leftHip, leftKnee);
    const rightDistance = calculateDistance(rightHip, rightKnee);

    // Configura as distâncias iniciais, se ainda não foram definidas
    if (squatStartDistance.left === null || squatStartDistance.right === null) {
        squatStartDistance = { left: leftDistance, right: rightDistance };
        const readyPose = new CustomEvent("pose:ready");
        window.dispatchEvent(readyPose);

        console.log("Distâncias iniciais definidas.");
        return;
    }

    // início descida
    if (
        (leftDistance < squatStartDistance.left || rightDistance < squatStartDistance.right) &&
        !isSquatting
    ) {
        squatFrames++;
        squatEndDistance.left = Math.min(leftDistance, squatEndDistance.left);
        squatEndDistance.right = Math.min(rightDistance, squatEndDistance.right);

        if (squatFrames >= stabilityFrames) {
            isSquatting = true;
            squatFrames = 0;
            currentSquatPoses = []; // Reinicia para o novo agachamento

            return "performing";
        }
    }
    //descendo
    else if (
        (leftDistance < squatStartDistance.left || rightDistance < squatStartDistance.right) &&
        isSquatting
    ) {
        //squatFrames++;
        squatEndDistance.left = Math.min(leftDistance, squatEndDistance.left);
        squatEndDistance.right = Math.min(rightDistance, squatEndDistance.right);
        squatDepth.right = Math.min(rightDistance, squatDepth.right);
        squatDepth.left = Math.min(leftDistance, squatDepth.left);

    }
    //início de subida
    else if (
        (squatDepth.left <=squatEndDistance.left+minimoSquat*squatEndDistance.left &&
        squarDepth.right <= squatEndDistance.right+minimoSquat*squatEndDistance.right) && 
        (leftDistance > squatDepth.left || rightDistance > squatDepth.right) && isSquatting
    ) {
        upSquatFrames++;
        //squatEndDistance.left = Math.min(leftDistance, squatEndDistance.left);
        //squatEndDistance.right = Math.min(rightDistance, squatEndDistance.right);
        //squatDepth.right = Math.min(rightDistance, squatDepth.right);
        //squatDepth.left = Math.min(leftDistance, squatDepth.left);
        
        if (upSquatFrames >= stabilityFrames) {
            
            isUpSquatting = true;
            upSquatFrames = 0;
           
            currentSquatPoses = []; // Reinicia para o novo agachamento
           
        }
        
    }
    //subindo
    else if (
        (leftDistance > squatDepth.left || rightDistance > squatDepth.right) && 
        isSquatting && isUpSquatting
    ) {
        squatStartDistance.left = Math.max(leftDistance, squatStartDistance.left);
        squatStartDistance.right = Math.max(rightDistance, squatStartDistance.right);

    }
    // Fase chegada
    else if (
        leftDistance >= squatStartDistance.left-erro*squatStartDistance.left && 
        rightDistance >= squatStartDistance.right-erro*squatStartDistance.right && 
        isSquatting && isUpSquatting
    ) {
        squatFrames++;

        if (squatFrames >= stabilityFrames) {
            isSquatting = false;
            isUpSquatting = false;
            squatDepth = { left: Infinity, right: infinity };
            squatFrames = 0;
            quality = 100 * (1 - ((squatDepth.left+squatDepth.right)/2) - ((squatEndDistance.left+squatEndDistance.right)/2) ) / (minimoSquat * ((squatEndDistance.left+squatEndDistance.right)/2));
            dispatchSquatEvents()

            return "completed";
        }
    } else {
        // Reinicia o contador se não houver mudanças significativas
        //squatFrames = 0;
        console.log("erro\n");
    }
}

// Função para calcular a distância entre dois pontos
function calculateDistance(pointA, pointB) {
    return Math.sqrt(
        Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2)
    );
}

function dispatchSquatEvents() {
    const squatDetails = {
        instant: new Date().toISOString(),
        quality: quality,
    };

    const squatEvent = new CustomEvent("squatDetected", { detail: squatDetails });
    window.dispatchEvent(squatEvent);
    
    if (!isFirstSquat) {
        const firstSquatEvent = new CustomEvent("firstSquat");
        window.dispatchEvent(firstSquatEvent);
        isFirstSquat = true;
    }
}