// Variáveis globais para armazenar estados e configurações
let detectorReady = false;
let detector;
let threshold = 0.3; // Valor mínimo de score
let squatStartDistance = { left: null, right: null };
let squatEndDistance = { left: Infinity, right: Infinity };
let isSquatting = false;
let squatFrames = 0;
let stabilityFrames = 3; // Número de frames para considerar estabilidade
let isFirstSquat = false; // Flag para o primeiro agachamento
let currentSquatPoses = [];

// === ADICIONADO PARA PROFUNDIDADE ===
// Distâncias normalizadas de referência e mínimo durante o agachamento
let normalizedStartDist = { left: null, right: null };
let normalizedMinDist   = { left: Infinity, right: Infinity };

// Função para calcular a distância euclidiana
function calculateDistance(pointA, pointB) {
  return Math.hypot(pointA.x - pointB.x, pointA.y - pointB.y);
}

// Função para normalizar uma distância pelo width do quadril
function normalize(dist, hipLeft, hipRight) {
  const ref = calculateDistance(hipLeft, hipRight);
  return dist / ref;
}

// Função que calcula profundidade e dispara evento
function computeDepthAndDispatch() {
  const depthL = 1 - (normalizedMinDist.left  / normalizedStartDist.left);
  const depthR = 1 - (normalizedMinDist.right / normalizedStartDist.right);
  const depth  = Math.min(depthL, depthR);

  let level;
  if (depth < 0.10)      level = "raso";
  else if (depth < 0.25) level = "paralelo";
  else                   level = "profundo";

  const detail = { depth, level, instant: new Date().toISOString() };
  console.log(detail)
}

// Listener para disparar cálculo de profundidade após detecção
window.addEventListener("squatDetected", () => {
  computeDepthAndDispatch();
  // Reseta para próximo agachamento
  normalizedMinDist = { left: Infinity, right: Infinity };
});

// =====================================================

// Função para preparar o detector
async function prepareDetector() {
    detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
    );
    detectorReady = true;

    const readyDetector = new CustomEvent("detector:ready");
    window.dispatchEvent(readyDetector);

    console.log("Detector pronto.");
}

// Função para detectar poses continuamente
async function detectPose() {
    if (!detector) return null;

    const video = document.getElementById("video");
    const poses = await detector.estimatePoses(video);

    if (poses.length > 0) {
        const extractedKeypoints = extractKeypoints(poses[0].keypoints);
        if (extractedKeypoints.leftHip && extractedKeypoints.rightHip &&
            extractedKeypoints.leftKnee && extractedKeypoints.rightKnee) {
            
            // === ADICIONADO: atualiza normalização a cada frame ===
            const rawLeftD  = calculateDistance(extractedKeypoints.leftHip,  extractedKeypoints.leftKnee);
            const rawRightD = calculateDistance(extractedKeypoints.rightHip, extractedKeypoints.rightKnee);
            const normLeft  = normalize(rawLeftD,  extractedKeypoints.leftHip,  extractedKeypoints.rightHip);
            const normRight = normalize(rawRightD, extractedKeypoints.leftHip,  extractedKeypoints.rightHip);

            if (normalizedStartDist.left !== null && isSquatting) {
                // atualiza mínimos normalizados durante a descida
                normalizedMinDist.left  = Math.min(normalizedMinDist.left,  normLeft);
                normalizedMinDist.right = Math.min(normalizedMinDist.right, normRight);
            }

            const movementStatus = processPose(extractedKeypoints);
            if (movementStatus) console.log(movementStatus);
        }
    }

    requestAnimationFrame(detectPose);
}

// Função que extrai os keypoints filtrando pelo score
function extractKeypoints(keypoints) {
    const filtered = keypoints.filter((kp) => kp.score > threshold);
    return {
        leftHip: filtered.find((kp) => kp.name === "left_hip"),
        rightHip: filtered.find((kp) => kp.name === "right_hip"),
        leftKnee: filtered.find((kp) => kp.name === "left_knee"),
        rightKnee: filtered.find((kp) => kp.name === "right_knee"),
    };
}

// Função que processa a pose e calcula as distâncias dos keypoints
function processPose(pose) {
    const { leftHip, rightHip, leftKnee, rightKnee } = pose;

    const leftDistance = calculateDistance(leftHip, leftKnee);
    const rightDistance = calculateDistance(rightHip, rightKnee);

    // Configura as distâncias iniciais, se ainda não foram definidas
    if (squatStartDistance.left === null || squatStartDistance.right === null) {
        squatStartDistance = { left: leftDistance, right: rightDistance };
        const readyPose = new CustomEvent("pose:ready");
        window.dispatchEvent(readyPose);

        // === ADICIONADO: define distâncias normalizadas iniciais ===
        normalizedStartDist.left  = normalize(leftDistance,  leftHip, rightHip);
        normalizedStartDist.right = normalize(rightDistance, leftHip, rightHip);

        console.log("Distâncias iniciais definidas.");
        return;
    }

    // Fase de descida do agachamento
    if (
        (leftDistance < squatStartDistance.left || rightDistance < squatStartDistance.right) &&
        !isSquatting
    ) {
        squatFrames++;
        squatEndDistance.left = Math.min(leftDistance, squatEndDistance.left);
        squatEndDistance.right = Math.min(rightDistance, squatEndDistance.right);

        if (squatFrames >= stabilityFrames) {
            isSquatting = true;
            squatFrames = 0;
            currentSquatPoses = []; // Reinicia para o novo agachamento

            return "performing";
        }
    }
    // Fase de subida do agachamento
    else if (
        (leftDistance > squatStartDistance.left || rightDistance > squatStartDistance.right) &&
        isSquatting
    ) {
        squatFrames++;

        if (squatFrames >= stabilityFrames) {
            isSquatting = false;
            squatFrames = 0;

            dispatchSquatEvents()

            return "completed";
        }
    } else {
        // Reinicia o contador se não houver mudanças significativas
        squatFrames = 0;
    }
}

// Função para despachar eventos de squat
function dispatchSquatEvents() {
    const squatDetails = {
        instant: new Date().toISOString(),
        quality: 10,
    };

    const squatEvent = new CustomEvent("squatDetected", { detail: squatDetails });
    window.dispatchEvent(squatEvent);

    if (!isFirstSquat) {
        const firstSquatEvent = new CustomEvent("firstSquat");
        window.dispatchEvent(firstSquatEvent);
        isFirstSquat = true;
    }
}